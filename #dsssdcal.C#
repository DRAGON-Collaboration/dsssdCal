#include <cstdio>
#include <cstring>
#include <sstream>
#include <Riostream.h>
#include <TString.h>
#include <TFile.h>
#include <TFitResult.h>
#include <TSystem.h>
#include <TDirectory.h>
#include <TH1.h>
#include <TH2.h>
#include <TTree.h>
#include <TGraph.h>
#include <TMath.h>


const Int_t nstrips = 16;
const Int_t cut     = 500;
const Double_t alpha_E[3] = {5.15659,5.48556,5.80477}; // alpha energies of triple alpha source in MeV
const Double_t dLayer     = 0.000374; // dead layer thickness (Al equivalent) in mm (from C. Wrede's thesis).
const Double_t dEdx[3]    = {160.1167,154.1106,148.9053}; // stopping powers (MeV/mm) of alphas in Al corresponding to above energies according to SRIM 2008
const Double_t E_peak[3]  = {alpha_E[0]-dEdx[0]*dLayer,alpha_E[1]-dEdx[1]*dLayer,alpha_E[2]-dEdx[2]*dLayer};
const Double_t sigma      = 3;
const Double_t thresh     = 0.25;


Double_t pulser(const char *fname, Int_t strip){

	TFile *f=TFile::Open(fname);

	TH1F *h1 = new TH1F("h1","h1",1024,0,4096);
	Double_t offset;

	t3->Draw(Form("dsssd.ecal[%i]>>h1",strip),Form("dsssd.ecal[%i]>200",strip),"goff");
	TSpectrum *s = new TSpectrum();
	Int_t nfound = s->Search(h1,sigma,"",thresh);
	const int npoints = nfound;
	cout << "Found " << nfound << " pulser peaks in strip " << strip << endl;

  if (nfound < 3){
    cout << "WARNING: Found insufficient number of pulser peaks to perform offset calibration fit for strip " << strip << "; skipping offset calibration." << endl;
		offset = 0;
    return offset;
    h1->Delete();
  }

	else{
		Float_t *xpeaks = s->GetPositionX();
		Int_t index[npoints];
		TMath::Sort(npoints,xpeaks,index,0);

		Float_t xsort;
		Double_t pulser;
		TGraph *g1=new TGraph(npoints);

		for (Int_t p=0; p<npoints; p++){
			xsort   = xpeaks[index[p]];
			pulser  = (p+1)/2.;
			g1->SetPoint(p,pulser,xsort);
			cout << p << "\t" << pulser << "\t" << xsort << "\n";
		}

		// new TCanvas();
		// g1->SetMarkerStyle(21);
		// g1->Draw("AP");
		TFitResultPtr fit=g1->Fit("pol1","qns");
		offset = fit->Value(0);
		cout << offset << endl;
		// Double_t slope     = fit->Value(1);

		return offset;

		h1->Delete();
		f->Close();
	}

}

Double_t *alpha(const char *fname,Int_t strip,Double_t offset){

	TFile *f=TFile::Open(fname);

  TH1F *h1 = new TH1F("h1","h1",1024,0,4095);
	Double_t slope;
	Double_t intercept;

	dragon::Tail* ptail = new dragon::Tail();
	t3->SetBranchAddress("tail", &ptail);
	for(Long_t evt = 0; evt < t3->GetEntries(); evt++) {
		t3->GetEntry(evt);
		Double_t val = ptail->dsssd.ecal[strip]-offset;
		if(val<cut) continue;
		h1->Fill(val);
	}

  // t3->Draw(Form("dsssd.ecal[%i]-%d>>h1",strip,offset),Form("dsssd.ecal[%i]-%d>%i",strip,offset,cut));
  TSpectrum *s = new TSpectrum();
  const Int_t nfound = s->Search(h1,sigma,"",thresh);
  cout << "Found " << nfound << " alpha peaks in strip " << strip << endl;

  if (nfound != 3){
    cout << "WARNING: Failed to find 3 alpha peaks for strip " << strip << "; skipping calibration" << endl;
		slope = 1;
    return slope;
    h1->Delete();
  }

  else{

    const Int_t npoints = nfound;
		Float_t *xpeaks=s->GetPositionX();

    Float_t xsort;
    Int_t index[npoints];
    TMath::Sort(npoints,xpeaks,index,kFALSE);
    TGraph *g1=new TGraph(npoints);

    for (Int_t p=0; p<nfound; p++){
      xsort = xpeaks[index[p]];
      g1->SetPoint(p,xsort,E_peak[p]);
			cout << p << "\t" << xsort << "\t" << E_peak[p] << "\n";
    }

    // new TCanvas();
    // g1->SetMarkerStyle(21);
    // g1->Draw("AP");
    // g1->Fit("pol1","Q");
    TFitResultPtr fit = g1->Fit("pol1","qns");
		Double_t *par=new Double_t[2];
		// intercept = fit->Value(0);
		// slope     = fit->Value(1);
		par[0] = fit->Value(0);
    par[1] = fit->Value(1);
		cout << par[0] << "\t" << par[1] << "\n"; 
    return par;
    h1->Delete();
  }

	f->Close();
  
}

void dsssdcal(const char *f1, const char *f2){

  
  Double_t offset[nstrips];
  Double_t gain[nstrips];
	Double_t intercept[nstrips];


  // Get offsets and energy calibration parameters for front strips
  for (Int_t i=0;i<nstrips;i++){
		offset[i]  = pulser(f1,i);
		Double_t *par=new Double_t[2];
		par    = alpha(f2,i,offset[i]);
		intercept[i] = par[0];
		gain[i] = par[1];
		// par.Delete();
  }

  // Get offsets and energy calibration parameters for back strips
  for (Int_t i=16;i<nstrips;i++){
		offset[i]  = pulser(f1,i);
		Double_t *par=alpha(f2,i,offset[i]);
		intercept[i] = par[0];
		gain[i] = par[1];
		delete[] par;
  }


	// Write slopes and offsets to odb
	// for(Int_t i=0; i< 32; ++i) {
	// 	gSystem->Exec(Form("odbedit -c \"set /dragon/dsssd/variables/adc/slope[%d] %.6g\"\n", i, gain[i]));
	// 	gSystem->Exec(Form("odbedit -c \"set /dragon/dsssd/variables/adc/offset_a[%d] %.6g\"\n", i,offset_a[i]));
	// }
	// cout << "ATTENTION: Gains and offsets written to odb!\n";

	// Save current odb state to xml file
	// gSystem->Exec("odbedit -c 'save -x dsssdcal.xml'"); // save calibration as xml file in cwd
	// cout "Current odb state saved to dsssd.xml in cwd and copied to $DH.\n";


	TCanvas *c0=new TCanvas();
	TH2F* h0=new TH2F("h0","",nstrips,0,nstrips-1,1024,0,4096);
	t3->Draw("dsssd.ecal[]:Iteration$>>h0","","colz");
	TCanvas *c1=new TCanvas();
	TH1F* h2=new TH1F("h2","",1024,0,4096);
	t3->Draw("dsssd.efront>>h2","dsssd.efront>350");

	// Draw calibrated summary spectrum
	TCanvas *c2=new TCanvas();
	TH2F* dsssd_cal = new TH2F("dsssd_cal", "",nstrips,0,nstrips,2048,0,20);
	dragon::Tail* ptail = new dragon::Tail();
	t3->SetBranchAddress("tail", &ptail);
	for(Long_t evt = 0; evt < t3->GetEntries(); evt++) {
		t3->GetEntry(evt);
		for(Int_t i=0; i<nstrips; i++){
			Double_t val = (ptail->dsssd.ecal[i]-offset[i])*gain[i]+intercept[i];
			if(val<1.5) continue;
			dsssd_cal->Fill(i,val);
		}
	}

	dsssd_cal->GetYaxis()->SetRangeUser(0,8);
 	dsssd_cal->Draw("colz");

	TCanvas *c3=new TCanvas();
	TH1D* py=dsssd_cal->ProjectionY("",0,8);
	py->Draw();

	t3->ResetBranchAddresses();
	delete ptail;

}

